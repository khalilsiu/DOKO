{"ast":null,"code":"import _regeneratorRuntime from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { pick } from 'lodash';\nimport metaverses from '../../constants/metaverses';\nimport OpenSeaAPI from '../../libs/opensea-api';\nimport { camelize, getCoordinates } from '../../utils/utils';\nvar initialState = [];\nexport var preprocess = function preprocess(asset) {\n  var picked = pick(asset, ['id', 'token_id', 'image_url', 'image_preview_url', 'image_thumbnail_url', 'image_original_url', 'name', 'asset_contract', 'traits']);\n  picked.asset_contract = pick(picked.asset_contract, ['address']);\n  picked.traits = picked.traits.map(function (trait) {\n    return pick(trait, ['trait_type', 'value']);\n  });\n  var coordinates = getCoordinates(asset.collection.name, asset);\n  return camelize(_objectSpread(_objectSpread({}, picked), {}, {\n    coordinates: coordinates\n  }));\n};\nexport var fetchAssets = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n    var assetsFromResponse, offset, assets, nfts, _loop;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            assetsFromResponse = [''];\n            offset = 0;\n            assets = [];\n            nfts = Array(metaverses.length).fill(null).map(function () {\n              return [];\n            });\n            _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n              var params, response;\n              return _regeneratorRuntime.wrap(function _loop$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      params = new URLSearchParams();\n                      params.append('limit', '50');\n                      params.append('owner', address);\n                      params.append('offset', offset.toString());\n                      metaverses.flatMap(function (metaverse) {\n                        return metaverse.addresses;\n                      }).forEach(function (contractAddress) {\n                        params.append('asset_contract_addresses', contractAddress);\n                      });\n                      _context.next = 7;\n                      return OpenSeaAPI.get('/assets', {\n                        params: params\n                      });\n\n                    case 7:\n                      response = _context.sent;\n                      assetsFromResponse = response.data.assets;\n                      assets.push.apply(assets, _toConsumableArray(assetsFromResponse));\n                      offset += 50;\n\n                    case 11:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _loop);\n            });\n\n          case 5:\n            if (!assetsFromResponse.length) {\n              _context2.next = 9;\n              break;\n            }\n\n            return _context2.delegateYield(_loop(), \"t0\", 7);\n\n          case 7:\n            _context2.next = 5;\n            break;\n\n          case 9:\n            assets.forEach(function (asset) {\n              if (!asset.asset_contract) {\n                return;\n              }\n\n              metaverses.forEach(function (metaverse, index) {\n                // no differentiation within same collection\n                if (metaverse.addresses.includes(asset.asset_contract.address)) {\n                  nfts[index].push(preprocess(asset));\n                }\n              });\n            });\n            return _context2.abrupt(\"return\", nfts);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchAssets(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var fetchProfileOwnership = createAsyncThunk('ProfileOwnership/fetchProfileOwnership', /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(addresses) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", Promise.all(addresses.map( /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address) {\n                return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.t0 = address;\n                        _context3.next = 3;\n                        return fetchAssets(address);\n\n                      case 3:\n                        _context3.t1 = _context3.sent;\n                        return _context3.abrupt(\"return\", {\n                          address: _context3.t0,\n                          assets: _context3.t1\n                        });\n\n                      case 5:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x3) {\n                return _ref3.apply(this, arguments);\n              };\n            }())));\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}());\nvar profileOwnershipSlice = createSlice({\n  name: 'ProfileOwnership',\n  initialState: initialState,\n  reducers: {},\n  extraReducers: function extraReducers(builder) {\n    builder.addCase(fetchProfileOwnership.fulfilled, function (state, action) {\n      return action.payload;\n    });\n  }\n}); // export const { getUserOwnership } = profileOwnershipSlice.actions;\n\nexport var profileOwnership = profileOwnershipSlice.reducer;","map":{"version":3,"sources":["/Users/anthonysiu/doko/DOKO/client/src/store/meta-nft-collections/profileOwnershipSlice.ts"],"names":["createSlice","createAsyncThunk","pick","metaverses","OpenSeaAPI","camelize","getCoordinates","initialState","preprocess","asset","picked","asset_contract","traits","map","trait","coordinates","collection","name","fetchAssets","address","assetsFromResponse","offset","assets","nfts","Array","length","fill","params","URLSearchParams","append","toString","flatMap","metaverse","addresses","forEach","contractAddress","get","response","data","push","index","includes","fetchProfileOwnership","Promise","all","profileOwnershipSlice","reducers","extraReducers","builder","addCase","fulfilled","state","action","payload","profileOwnership","reducer"],"mappings":"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","sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { pick } from 'lodash';\nimport metaverses from '../../constants/metaverses';\nimport OpenSeaAPI from '../../libs/opensea-api';\nimport { camelize, getCoordinates } from '../../utils/utils';\n\nexport interface Trait {\n  traitType: string;\n  value: string;\n}\n\nexport interface Asset {\n  floorPrice: number;\n  id: string;\n  tokenId: string;\n  imageUrl: string;\n  imageOriginalUrl: string;\n  coordinates: L.LatLngExpression;\n  imagePreviewUrl: string;\n  imageThumbnailUrl: string;\n  name: string;\n  assetContract: {\n    address: string;\n  };\n  traits: Trait[];\n}\n\nexport interface AddressOwnership {\n  // TODO: add type back\n  // no count needed, can be inferred from nfts.length\n  // price should be another domain not User\n  assets: Asset[][];\n  address: string;\n}\n\nconst initialState: AddressOwnership[] = [];\n\nexport const preprocess = (asset: any): Asset => {\n  const picked = pick(asset, [\n    'id',\n    'token_id',\n    'image_url',\n    'image_preview_url',\n    'image_thumbnail_url',\n    'image_original_url',\n    'name',\n    'asset_contract',\n    'traits',\n  ]);\n  picked.asset_contract = pick(picked.asset_contract, ['address']);\n  picked.traits = picked.traits.map((trait) => pick(trait, ['trait_type', 'value']));\n\n  const coordinates: L.LatLngExpression = getCoordinates(asset.collection.name, asset);\n\n  return camelize({ ...picked, coordinates });\n};\n\nexport const fetchAssets = async (address: string) => {\n  let assetsFromResponse: any[] = [''];\n  let offset = 0;\n  const assets: any[] = [];\n  const nfts: Asset[][] = Array(metaverses.length)\n    .fill(null)\n    .map(() => []);\n  while (assetsFromResponse.length) {\n    const params = new URLSearchParams();\n    params.append('limit', '50');\n    params.append('owner', address);\n    params.append('offset', offset.toString());\n    metaverses\n      .flatMap((metaverse) => metaverse.addresses)\n      .forEach((contractAddress) => {\n        params.append('asset_contract_addresses', contractAddress);\n      });\n\n    const response = await OpenSeaAPI.get('/assets', { params });\n    assetsFromResponse = response.data.assets;\n    assets.push(...assetsFromResponse);\n    offset += 50;\n  }\n\n  assets.forEach((asset) => {\n    if (!asset.asset_contract) {\n      return;\n    }\n    metaverses.forEach((metaverse, index) => {\n      // no differentiation within same collection\n      if (metaverse.addresses.includes(asset.asset_contract.address)) {\n        nfts[index].push(preprocess(asset));\n      }\n    });\n  });\n  return nfts;\n};\n\nexport const fetchProfileOwnership = createAsyncThunk(\n  'ProfileOwnership/fetchProfileOwnership',\n  async (addresses: string[]): Promise<AddressOwnership[]> =>\n    Promise.all(\n      addresses.map(async (address) => ({\n        address,\n        assets: await fetchAssets(address),\n      })),\n    ),\n);\n\nconst profileOwnershipSlice = createSlice({\n  name: 'ProfileOwnership',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchProfileOwnership.fulfilled, (state, action) => {\n      return action.payload;\n    });\n  },\n});\n\n// export const { getUserOwnership } = profileOwnershipSlice.actions;\n\nexport const profileOwnership = profileOwnershipSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}