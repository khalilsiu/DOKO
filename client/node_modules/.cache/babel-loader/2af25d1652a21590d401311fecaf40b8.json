{"ast":null,"code":"import _regeneratorRuntime from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { getTokenInfo, getSolanaNFTMetadata, getTokenAccountsByOwner } from './metaplex/utils';\nimport { isSolAddress } from './utils';\nexport var getSolNftsCount = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n    var _tokenListRes$data, _tokenListRes$data$re, _tokenListRes$data$re2;\n\n    var tokenListRes, tokenInfoList;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return getTokenAccountsByOwner(address);\n\n          case 2:\n            tokenListRes = _context.sent;\n            tokenInfoList = ((_tokenListRes$data = tokenListRes.data) === null || _tokenListRes$data === void 0 ? void 0 : (_tokenListRes$data$re = _tokenListRes$data.result) === null || _tokenListRes$data$re === void 0 ? void 0 : (_tokenListRes$data$re2 = _tokenListRes$data$re.value) === null || _tokenListRes$data$re2 === void 0 ? void 0 : _tokenListRes$data$re2.map(function (token) {\n              return token.account.data.parsed.info;\n            })) || [];\n            return _context.abrupt(\"return\", tokenInfoList.filter(function (tokenInfo) {\n              if (tokenInfo.tokenAmount.amount === '1' && tokenInfo.tokenAmount.decimals === 0) {\n                return true;\n              }\n\n              return false;\n            }).length);\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getSolNftsCount(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var getSolNfts = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address) {\n    var _tokenListRes$data2, _tokenListRes$data2$r, _tokenListRes$data2$r2;\n\n    var params,\n        tokenListRes,\n        tokenInfoList,\n        promiseList,\n        NFTsMetadataRes,\n        nfts,\n        data,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            params = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n            if (!(!isSolAddress(address) || params.chain && params.chain.indexOf.solana === -1)) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", {\n              data: []\n            });\n\n          case 3:\n            _context2.next = 5;\n            return getTokenAccountsByOwner(address);\n\n          case 5:\n            tokenListRes = _context2.sent;\n            tokenInfoList = ((_tokenListRes$data2 = tokenListRes.data) === null || _tokenListRes$data2 === void 0 ? void 0 : (_tokenListRes$data2$r = _tokenListRes$data2.result) === null || _tokenListRes$data2$r === void 0 ? void 0 : (_tokenListRes$data2$r2 = _tokenListRes$data2$r.value) === null || _tokenListRes$data2$r2 === void 0 ? void 0 : _tokenListRes$data2$r2.map(function (token) {\n              return token.account.data.parsed.info;\n            })) || [];\n            promiseList = [];\n            tokenInfoList.forEach(function (tokenInfo) {\n              if (tokenInfo.tokenAmount.amount === '1' && tokenInfo.tokenAmount.decimals === 0) {\n                promiseList.push(getTokenInfo(tokenInfo.mint));\n              }\n            });\n            _context2.next = 11;\n            return Promise.all(promiseList);\n\n          case 11:\n            NFTsMetadataRes = _context2.sent;\n            NFTsMetadataRes.sort(function (a, b) {\n              if (!('direction' in params) || params.direction === 1) {\n                return a.data.name < b.data.name ? -1 : 1;\n              }\n\n              return a.data.name > b.data.name ? -1 : 1;\n            });\n            promiseList = [];\n            NFTsMetadataRes.forEach(function (metadata) {\n              promiseList.push(getSolanaNFTMetadata(metadata));\n            });\n            _context2.next = 17;\n            return Promise.all(promiseList);\n\n          case 17:\n            nfts = _context2.sent;\n            data = nfts.filter(function (x) {\n              return x;\n            }).map(function (value) {\n              return {\n                _id: value.mint,\n                name: value.metadata.data.name,\n                symbol: value.metadata.data.symbol,\n                owner_of: address,\n                chain: 'solana',\n                metadata: value.metadata.data,\n                updateAuthority: value.metadata.updateAuthority\n              };\n            });\n            return _context2.abrupt(\"return\", {\n              data: data\n            });\n\n          case 20:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function getSolNfts(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/anthonysiu/doko/DOKO/client/src/libs/solana.ts"],"names":["getTokenInfo","getSolanaNFTMetadata","getTokenAccountsByOwner","isSolAddress","getSolNftsCount","address","tokenListRes","tokenInfoList","data","result","value","map","token","account","parsed","info","filter","tokenInfo","tokenAmount","amount","decimals","length","getSolNfts","params","chain","indexOf","solana","promiseList","forEach","push","mint","Promise","all","NFTsMetadataRes","sort","a","b","direction","name","metadata","nfts","x","_id","symbol","owner_of","updateAuthority"],"mappings":"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","sourcesContent":["import { getTokenInfo, getSolanaNFTMetadata, getTokenAccountsByOwner } from './metaplex/utils';\nimport { Metadata } from './metaplex/classes';\nimport { isSolAddress } from './utils';\n\nexport const getSolNftsCount = async (address: string) => {\n  const tokenListRes = await getTokenAccountsByOwner(address);\n  const tokenInfoList =\n    tokenListRes.data?.result?.value?.map((token: any) => token.account.data.parsed.info) || [];\n  return tokenInfoList.filter((tokenInfo: any) => {\n    if (tokenInfo.tokenAmount.amount === '1' && tokenInfo.tokenAmount.decimals === 0) {\n      return true;\n    }\n    return false;\n  }).length;\n};\n\nexport const getSolNfts = async (address: string, params: any = {}) => {\n  if (!isSolAddress(address) || (params.chain && params.chain.indexOf.solana === -1)) {\n    return { data: [] };\n  }\n  const tokenListRes = await getTokenAccountsByOwner(address);\n  const tokenInfoList =\n    tokenListRes.data?.result?.value?.map((token: any) => token.account.data.parsed.info) || [];\n  let promiseList: any[] = [];\n  tokenInfoList.forEach((tokenInfo: any) => {\n    if (tokenInfo.tokenAmount.amount === '1' && tokenInfo.tokenAmount.decimals === 0) {\n      promiseList.push(getTokenInfo(tokenInfo.mint));\n    }\n  });\n  const NFTsMetadataRes: Metadata[] = await Promise.all(promiseList);\n  NFTsMetadataRes.sort((a: Metadata, b: Metadata): number => {\n    if (!('direction' in params) || params.direction === 1) {\n      return a.data.name < b.data.name ? -1 : 1;\n    }\n    return a.data.name > b.data.name ? -1 : 1;\n  });\n  promiseList = [];\n  NFTsMetadataRes.forEach((metadata: Metadata) => {\n    promiseList.push(getSolanaNFTMetadata(metadata));\n  });\n  const nfts = await Promise.all(promiseList);\n  const data = nfts\n    .filter((x) => x)\n    .map((value: any) => ({\n      _id: value.mint,\n      name: value.metadata.data.name,\n      symbol: value.metadata.data.symbol,\n      owner_of: address,\n      chain: 'solana',\n      metadata: value.metadata.data,\n      updateAuthority: value.metadata.updateAuthority,\n    }));\n  return { data };\n};\n"]},"metadata":{},"sourceType":"module"}