{"ast":null,"code":"import _toConsumableArray from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/anthonysiu/doko/DOKO/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport OpenSeaAPI from '../../libs/opensea-api';\nimport { formatTx, sortTxsByDates } from '../../libs/utils';\nexport var fetchNFTOpensea = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address, id) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", OpenSeaAPI.get(\"/asset/\".concat(address, \"/\").concat(id)));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchNFTOpensea(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var fetchOpenSeaEvents = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(asset_contract_address, token_id, offset, limit, event_types) {\n    var promises, _iterator, _step, eventType, events, merged_events, formatted, sorted;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            promises = [];\n            _iterator = _createForOfIteratorHelper(event_types);\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                eventType = _step.value;\n                promises.push(OpenSeaAPI.get('/events', {\n                  params: {\n                    only_opensea: false,\n                    asset_contract_address: asset_contract_address,\n                    token_id: token_id,\n                    offset: offset,\n                    limit: limit,\n                    event_type: eventType\n                  }\n                }));\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            _context2.prev = 3;\n            _context2.next = 6;\n            return Promise.all(promises);\n\n          case 6:\n            events = _context2.sent;\n            merged_events = [].concat(_toConsumableArray(events[0].data.asset_events), _toConsumableArray(events[1].data.asset_events), _toConsumableArray(events[2].data.asset_events));\n            formatted = merged_events.map(function (event) {\n              return formatTx(event, 'eth');\n            });\n            sorted = sortTxsByDates(formatted);\n            return _context2.abrupt(\"return\", sorted);\n\n          case 13:\n            _context2.prev = 13;\n            _context2.t0 = _context2[\"catch\"](3);\n            //\n            console.error(_context2.t0);\n            return _context2.abrupt(\"return\", []);\n\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[3, 13]]);\n  }));\n\n  return function fetchOpenSeaEvents(_x3, _x4, _x5, _x6, _x7) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport default fetchOpenSeaEvents;","map":{"version":3,"sources":["/Users/anthonysiu/doko/DOKO/client/src/modules/nft-individual/api.tsx"],"names":["OpenSeaAPI","formatTx","sortTxsByDates","fetchNFTOpensea","address","id","get","fetchOpenSeaEvents","asset_contract_address","token_id","offset","limit","event_types","promises","eventType","push","params","only_opensea","event_type","Promise","all","events","merged_events","data","asset_events","formatted","map","event","sorted","console","error"],"mappings":";;;;AAAA,OAAOA,UAAP,MAAuB,wBAAvB;AACA,SAASC,QAAT,EAAmBC,cAAnB,QAAyC,kBAAzC;AAEA,OAAO,IAAMC,eAAe;AAAA,sEAAG,iBAAOC,OAAP,EAAwBC,EAAxB;AAAA;AAAA;AAAA;AAAA;AAAA,6CAC7BL,UAAU,CAACM,GAAX,kBAAyBF,OAAzB,cAAoCC,EAApC,EAD6B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAfF,eAAe;AAAA;AAAA;AAAA,GAArB;AAGP,OAAO,IAAMI,kBAAkB;AAAA,uEAAG,kBAChCC,sBADgC,EAEhCC,QAFgC,EAGhCC,MAHgC,EAIhCC,KAJgC,EAKhCC,WALgC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAO1BC,YAAAA,QAP0B,GAOf,EAPe;AAAA,mDASRD,WATQ;;AAAA;AAShC,kEAAqC;AAA1BE,gBAAAA,SAA0B;AACnCD,gBAAAA,QAAQ,CAACE,IAAT,CACEf,UAAU,CAACM,GAAX,CAAe,SAAf,EAA0B;AACxBU,kBAAAA,MAAM,EAAE;AACNC,oBAAAA,YAAY,EAAE,KADR;AAENT,oBAAAA,sBAAsB,EAAtBA,sBAFM;AAGNC,oBAAAA,QAAQ,EAARA,QAHM;AAINC,oBAAAA,MAAM,EAANA,MAJM;AAKNC,oBAAAA,KAAK,EAALA,KALM;AAMNO,oBAAAA,UAAU,EAAEJ;AANN;AADgB,iBAA1B,CADF;AAYD;AAtB+B;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,mBAwBJK,OAAO,CAACC,GAAR,CAAYP,QAAZ,CAxBI;;AAAA;AAwBxBQ,YAAAA,MAxBwB;AAyBxBC,YAAAA,aAzBwB,gCA0BzBD,MAAM,CAAC,CAAD,CAAN,CAAUE,IAAV,CAAeC,YA1BU,sBA2BzBH,MAAM,CAAC,CAAD,CAAN,CAAUE,IAAV,CAAeC,YA3BU,sBA4BzBH,MAAM,CAAC,CAAD,CAAN,CAAUE,IAAV,CAAeC,YA5BU;AA8BxBC,YAAAA,SA9BwB,GA8BZH,aAAa,CAACI,GAAd,CAAkB,UAACC,KAAD;AAAA,qBAAgB1B,QAAQ,CAAC0B,KAAD,EAAQ,KAAR,CAAxB;AAAA,aAAlB,CA9BY;AA+BxBC,YAAAA,MA/BwB,GA+Bf1B,cAAc,CAACuB,SAAD,CA/BC;AAAA,8CAgCvBG,MAhCuB;;AAAA;AAAA;AAAA;AAkC9B;AACAC,YAAAA,OAAO,CAACC,KAAR;AAnC8B,8CAoCvB,EApCuB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAlBvB,kBAAkB;AAAA;AAAA;AAAA,GAAxB;AAwCP,eAAeA,kBAAf","sourcesContent":["import OpenSeaAPI from '../../libs/opensea-api';\nimport { formatTx, sortTxsByDates } from '../../libs/utils';\n\nexport const fetchNFTOpensea = async (address: string, id: string) =>\n  OpenSeaAPI.get(`/asset/${address}/${id}`);\n\nexport const fetchOpenSeaEvents = async (\n  asset_contract_address: string,\n  token_id: string,\n  offset: number,\n  limit: number,\n  event_types: string[],\n) => {\n  const promises = [] as any;\n\n  for (const eventType of event_types) {\n    promises.push(\n      OpenSeaAPI.get('/events', {\n        params: {\n          only_opensea: false,\n          asset_contract_address,\n          token_id,\n          offset,\n          limit,\n          event_type: eventType,\n        },\n      }),\n    );\n  }\n  try {\n    const events: any = await Promise.all(promises);\n    const merged_events = [\n      ...events[0].data.asset_events,\n      ...events[1].data.asset_events,\n      ...events[2].data.asset_events,\n    ];\n    const formatted = merged_events.map((event: any) => formatTx(event, 'eth'));\n    const sorted = sortTxsByDates(formatted);\n    return sorted;\n  } catch (err) {\n    //\n    console.error(err);\n    return [];\n  }\n};\n\nexport default fetchOpenSeaEvents;\n"]},"metadata":{},"sourceType":"module"}